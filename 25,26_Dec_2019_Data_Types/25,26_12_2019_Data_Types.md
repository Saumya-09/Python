### Python Native Datatypes
A Data type provides a set of values from which an expression may take its values. The type defines the operations that can be done on the data, the meaning of the data, and the way values of that type can be stored. Python supports the following data types:

- Numbers
- String
- List
- Tuple
- Dictionary
- Set

[![](https://intellipaat.com/mediaFiles/2019/02/pyhon3.png)](http://https://intellipaat.com/mediaFiles/2019/02/pyhon3.png)

[![](https://miro.medium.com/max/4142/1*Det-kkoSw9T4IZ4XrypVNQ.png)](http://https://miro.medium.com/max/4142/1*Det-kkoSw9T4IZ4XrypVNQ.png)

### String
A String is an array of characters. They are formed by a list of characters, which is really an "array of characters". They are less useful when storing information for the computer to use. An important characteristic of each string is its length, which is the number of characters in it. There are numerous algorithms for processing strings, including for searching, sorting, comparing and transforming.

In Python, string is a sequence of Unicode character . Unicode was introduced to include every character in all languages and bring uniformity in encoding. We can create them simply by enclosing characters in quotes. Python treats single quotes the same as double quotes.

```python
str = "Hello World"   //double quotes
str1 = 'Hello World!'//using single quotes
```
```python
str = "Hello World"
print (str[0])
print (str[6:11])
print (str + " !!")
print (len(str))

Output
H
World
Hello World !!
11
```


### List
Python List is one of the most frequently used and very versatile datatype. Lists work similarly to strings: use the len() function and square brackets [ ] to access data, with the first element at index 0.
```python
weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
print (weekdays[0])
print (weekdays[4])

Output:
Monday
Friday
```

### Tuple
A tuple is a container which holds a series of comma-separated values between parentheses. A tuple is similar to a list. Since, tuples are quite similar to lists , both of them are used in similar situations as well. The only the difference is that list is enclosed between square bracket, tuple between parenthesis and List have mutable objects whereas Tuple have immutable objects.
```python
my_Tuple_1 = (1,2,"Hello",3.14,"world")
print(my_Tuple_1)
print(my_Tuple_1[3])
my_Tuple_2 = (5,"six")
print(my_Tuple_1 + my_Tuple_2)


Output:
(1, 2, 'Hello', 3.14, 'world')
3.14
(1, 2, 'Hello', 3.14, 'world', 5, 'six')

```
### Dictionary
Pyhton Dictionaries allow you store and retrieve related information in a way that means something both to humans and computers. Dictionaries are non-ordered and contain "keys" and "values" . Each key is unique and the values can be just about anything, but usually they are string, int, or float, or a list of these things. Like lists dictionaries can easily be changed, can be shrunk and grown ad libitum at run time. Dictionaries don't support the sequence operation of the sequence data types like strings, tuples and lists. Dictionaries belong to the built-in mapping type.
```python
my_Dictionay = {'ID': 1110, 'Name':'John', 'Age': 12}
print (my_Dictionay['ID'])
print (my_Dictionay['Age'])
#insert
my_Dictionay['Total Marks']=600
print (my_Dictionay)

Output:
1110
12
{'Total Marks': 600, 'Age': 12, 'ID': 1110, 'Name': 'John'}
```

#### Type conversions:

Python has five standard Data Types. Sometimes it is necessary to convert values from one type to another. Python defines type conversion functions to directly convert one data type to another which is useful in day to day and competitive program development.

[![](http://net-informations.com/python/basics/img/conversion.png)](http://http://net-informations.com/python/basics/img/conversion.png)

Example: 
```python
String to integer
str =100
x = int(str)
y = x+ 200
print(y)

Output:
300
```
### Mutable vs. Immutable

Values of type int, float, bool, str are immutable.

In immutable data types, updating one value does not
affect the copy. Assignment makes a fresh copy of a
value.
Example:
```python
#Immutable
x=5
y=x
print(y)
Output: 5
x=7
print(y)
Output: 5
```
For mutable values, assignment does not make a
fresh copy.
List is mutable.

Example:
```python
#Mutable
l1=[1,3,5,7]
l2=l1
l1[2]=4
print(l1[2])
print(l2[2])
Output:
4
4
```
# List in Python



The most commonly used data structure in Python is List. Python list is a container like an array that holds an **ordered sequence** of objects. The object can be anything from a string to a number or the data of any available type.

A list can also be both homogenous as well as heterogeneous. It means we can store only integers or strings or both depending on the need. Next, every element rests at some position (i.e., index) in the list. The index can be used later to locate a particular item. The first index begins at zero, next is one, and so forth.

### Creating a List In Python

------------


There are multiple ways to form a list in Python.

- #### Subscript Operator

------------


The square brackets [ ] represent the subscript operator in Python. It does not require a symbol lookup or a function call. Hence, it turns out the fastest way to create a list in Python.

You can specify the elements inside [ ], separated by commas.

L1 = [] #An empty list
L2 = [a1, a2,...] #With elements
###### Note: The list can take any number of elements, and each may belong to a different type (a number or a string, etc.).

1. ###### blank list
L1 = []

2. ###### list of integers
L2 = [10, 20, 30]

3. ###### List of heterogenous data types
L3 = [1, "Hello", 3.4]

- #### List() Constructor

------------


Python includes a built-in list() method a.k.a constructor.

It accepts either a sequence or tuple as the argument and converts into a Python list.
##### Syntax
theList = list([n1, n2, ...] or [n1, n2, [x1, x2, ...]])
We can supply a standard or nested sequence as the input argument to the list() function. 

Below are some more examples demonstrating the Python list() method.

```python
 theList = list([1,2])
 theList
Output: [1, 2]

theList = list([1, 2, [1.1, 2.2]])
theList
[1, 2, [1.1, 2.2]]
len(theList)
Output: 3
```
- #### List Comprehension

------------


Python supports a concept known as** List Comprehension**. It helps in constructing lists in an entirely natural and easy way.

##### Syntax

**theList = [expression(iter) for iter in oldList if filter(iter)]**

It has square brackets grouping an expression followed by a for-in clause and zero or more if statements. The result will always be a list.

Example:- 

```python
theList = [iter for iter in range(5)]
print(theList)
Output: [0, 1, 2, 3, 4]
```

```python
 listofCountries = ["India","America","England","Germany","Brazil","Vietnam"]
 firstLetters = [ country[0] for country in listofCountries ]
 print(firstLetters)
Output: ['I', 'A', 'E', 'G', 'B', 'V']
```
```python
 months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
 oddMonths = [iter for index, iter in enumerate(months) if (index%2 == 0)]
 oddMonths
Output: ['jan', 'mar', 'may', 'jul', 'sep', 'nov']
```


- #### Creating A Multi-Dimensional List

------------


You can create a sequence with a pre-defined size by specifying an initial value for each element.

```python
 init_list = [0]*3
 print(init_list)
Output: [0, 0, 0]
```
```python
 two_dim_list = [ [0]*3 ] *3
 print(two_dim_list)
Output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

two_dim_list[0][2] = 1
print(two_dim_list)
Output: [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
```

### Operations on list

- #### Extending A List

------------


Python allows lists to re-size in many ways. You can do that just by adding two or more of them.

```python
L1 = ['a', 'b']
L2 = [1, 2]
L3 = ['Learn', 'Python']
L1 + L2 + L3
Output: ['a', 'b', 1, 2, 'Learn', 'Python']
```
```python
L1 = ['a', 'b']
L2 = ['c', 'd']
L1.extend(L2)
print(L1)
Output: ['a', 'b', 'c', 'd']
```

```python
L1 = ['x', 'y']
L1.append(['a', 'b'])
L1
Output: ['x', 'y', ['a', 'b']]
```
- #### Concatenation

Lists can be glued together using +.
Note that + always produces a new list.

Example:

```python
l1=[1,3,5,7]
l1=l1+[9]
print(l1)
Output: [1, 3, 5, 7, 9]
```
- ####  Updating Lists

Example:

```python
list = ['physics', 'chemistry', 1997, 2000]
print("Value available at index 2 : ", list[2])
list[2] = 2001
print("New value at index 2 : ", list[2])
Output:
Value available at index 2 : 1997
New value available at index 2 : 2001
```
- #### Deleting List Elements

Example:
```python
list1 = ['physics', 'chemistry', 1997, 2000]
print(list1)
del list1[2]
print("After deleting value at index 2 : ")
print(list1)
Output:
['physics', 'chemistry', 1997, 2000]
After deleting value at index 2 : ['physics', 'chemistry', 2000]
```
- #### Length of list

Example:

```python
list1, list2 = [123, 'xyz', 'zara'], [456, 'abc']
print("First list length : ", len(list1))
print ("Second list length : ", len(list2))
Output:
First list length : 3
Second list length : 2
```
- #### Appending in a List

Example:

```python
aList = [123, 'xyz', 'zara', 'abc']
aList.append(2009);
print("Updated List : ", aList)
Output:
Updated List : [123, 'xyz', 'zara', 'abc', 2009]
```
- #### list.copy()

Example:

```python
list1 = ['cat', 0, 6.7]
new_list = list1.copy()
new_list.append('dog')
print('Old List: ', list1)
print('New List: ', new_list)
Output:
Old List: ['cat', 0, 6.7]
New List: ['cat', 0, 6.7, 'dog']
```

- #### list.index()

Example:

```python
aList = [123, 'xyz', 'zara', 'abc']
print "Index for xyz : ", aList.index( 'xyz' )
print "Index for zara : ", aList.index( 'zara' )
Output:
Index for xyz : 1
Index for zara : 2
```

- #### list.insert()

Example:

```python
aList = [123, 'xyz', 'zara', 'abc']
aList.insert( 3,2009)
print "Final List : ", aList
Output:
Final List : [123, 'xyz', 'zara', 2009, 'abc']
```

- #### list.pop()

Example:

```python
aList = [123, 'xyz', 'zara', 'abc']
print("A List : ", aList.pop())
print(aList)
print("B List : ", aList.pop(2))
print(aList)
Output:
A List : abc
[123, 'xyz', 'zara']
B List : zara
[123, 'xyz']
```

- #### list.remove()

Example:

```python
aList = [123, 'xyz', 'zara', 'abc', 'xyz'];
aList.remove('xyz');
print "List : ", aList
aList.remove('abc');
print "List : ", aList
Output:
List : [123, 'zara', 'abc', 'xyz']
List : [123, 'zara', 'xyz']
```
-  #### list.reverse()

Example:

```python
aList = [123, 'xyz', 'zara', 'abc', 'xyz'];
aList.reverse();
print("List : ", aList)
Output:
List : ['xyz', 'abc', 'zara', 'xyz', 123]
```


- #### list.sort()

Example:

```python
aList = ['xyz', 'zara', 'abc', 'xyz'];
aList.sort();
print("List : ", aList)
Output:
List : ['abc', 'xyz', 'xyz', 'zara']
```

Example:

```python
l=[1,2,3,4]
l[1:3]=[6,7]
print(l)
l[1:1]=[8,9]
print(l)
l[1]=[8,9]
print(l)
Output:
[1, 6, 7, 4]
[1, 8, 9, 6, 7, 4]
[1, [8, 9], 9, 6, 7, 4]
```

# Dynamic Input in Python

```python
#create an empty list
a = [];
#take limt as input
lim = input("Enter limit")
#this is python style of for loop
#here i will start from 0 and will go upto limit
for i in range (0, int(lim)):
    #take input from user one by one and append to list
    elem = input("")
    a.append(int(elem))
print(a)

Output:
Enter limit5
1
2
3
4
5
[1, 2, 3, 4, 5]
```

# Tuples in Python

- A tuple is a sequence of immutable Python objects.

- Tuples are sequences, just like lists.

-  The differences between tuples and lists are, the
tuples cannot be changed unlike lists and tuples
use parentheses (), whereas lists use square brackets [].

### Creating Tuple

Creating a tuple is as simple as putting different
comma-separated values.

```python
tup1 = ('physics', 'chemistry', 1997, 2000)
tup2 = (1, 2, 3, 4, 5 )
tup3 = 'a', 'b', 'c', 'd'
tup4 = (1,"a",[3,4],(1,2,3))
print tup4[2]
Output: [3,4]
print tup4[2][0]
Output: 3
```

Having one element within parentheses is not
enough. We will need a trailing comma to indicate
that it is in fact a tuple.

Example:
```python
t = (1)
print(t[0])
```

#### Accessing Values in Tuples

------------



To access values in tuple, use the square brackets
for slicing along with the index or indices to obtain
value available at that index.

```python
tup1 = ('physics', 'chemistry', 1997, 2000)
tup2 = (1, 2, 3, 4, 5, 6, 7 )
print("tup1[0]: ", tup1[0])
print("tup2[1:5]: ", tup2[1:5])
Output:
tup1[0]: physics
tup2[1:5]: (2, 3, 4, 5)
```

#### Nested tuples are accessed using nested indexing.

------------



Example:

```python
t = ("mouse",[8,4,6],(1,2,3))
print(t[0])
print(t[0][3])
print(t[1][2])
Output:
mouse
s
6
```

#### Adding elements to tuple

------------


Example:

```python
t=()
for i in range(5):
	t=t+(i,)
	print(t)
Output:
(0, 1, 2, 3, 4)
```

#### Updating Tuple

------------



Tuples are immutable which means you cannot
update or change the values of tuple elements once
inserted.

```python
tup1 = (12, 34.56)
tup2 = ('abc', 'xyz')
# Following action is not valid for tuples
tup1[0] = 100
# So let's create a new tuple as follows
tup3 = tup1 + tup2
print(tup3)
Output:
(12, 34.56, 'abc', 'xyz')
```

If the element is itself a mutable data type like list,
its nested items can be changed.


#### Deleting Tuple Elements

------------



Removing individual tuple elements is not
possible.
To explicitly remove an entire tuple, just use the
del statement.

Example:

```python
tup = ('physics', 'chemistry', 1997, 2000)
print(tup)
del tup
print("After deleting tup : ")
print(tup)
```

#### Basic Tuples Operations

------------



Tuples respond to the + and * operators much like
strings; they mean concatenation and repetition here
too, except that the result is a new tuple, not a string.

**Indexing, Slicing**

Because tuples are sequences, indexing and slicing
work the same way for tuples as they do for
strings.

Example:

- #### Length of Tuple
```python
tuple1, tuple2 = (123, 'xyz', 'zara'), (456, 'abc')
print("First tuple length : ", len(tuple1))
print("Second tuple length : ", len(tuple2))
Output:
First tuple length : 3
Second tuple length : 2
```

Example:
- #### Max-Min of Tuple
```python
tuple1, tuple2 = ('xyz', 'zara', 'abc'), (456, 700, 200)
print("Max value element : ", max(tuple1))
print("Min value element : ", min(tuple2))
Output:
Max value element : zara
Min value element : 200
```
Example:
- #### List to Tuple
```python
aList = [123, 'xyz', 'zara', 'abc']
aTuple = tuple(aList)
print("Tuple elements : ", aTuple)
Output:
Tuple elements : (123, 'xyz', 'zara', 'abc')
```

Example:
- #### Count in python
```python
t = (1,2,3,1,2,1,4)
print(t.count(1))
Output:
3
```

- #### index(x)

Example:

```python
t = (1,2,3,1,2,1,4)
print(t.index(2))
Output:
1
```

- #### Tuple Membership Test

We can test if an item exists in a tuple or not, using
the keyword in.

Example:

```python
t = (1,2,3,1,2,1,4)
print(1 in t)
print(2 not in t)
Output:
True
False
```

- #### Iterating Through a Tuple

Example:

```python
for name in ('abc','xyz'):
	print("Hello",name)
Output:
Hello abc
Hello xyz
```

- #### Tuple with string functions

Example:

```python
s=input()
t=tuple(s.split(“ " ))
print(t)
Output:
I am student
(‘I', 'am', ‘student')
```

### Advantages over lists

- Tuples that contain immutable elements can be
used as key/value pair for a dictionary. With list,
this is not possible.

- If you have data that doesn't change, implementing
it as tuple will guarantee that it remains
write-protected.

```python
l=(1,2,(3,4),[1,2],"hello")
l=l+(4,)
print(l)
l(2).append(4)
print(l)
del l(1) #This will throw an error
Output:
(1, 2, (3, 4), [1, 2], 'hello', 4)
(1, 2, (3, 4), [1, 2, 4], 'hello', 4)
```
# Sets in Python

[![Set Theory](https://www.python-course.eu/images/sets_with_notations.png "Set Theory")](http://https://www.python-course.eu/images/sets_with_notations.png "Set Theory")


### What is a set in Python?

------------


- A set is an unordered collection of items. Every element is unique (no duplicates) and must be immutable (which cannot be changed).
- However, the set itself is mutable. We can add or remove items from it.
- Sets can be used to perform mathematical set operations like union, intersection, symmetric difference etc.

### How to create a set?

------------


- A set is created by placing all the items (elements) inside curly braces {}, separated by comma or by using the built-in function set().

- It can have any number of items and they may be of different types (integer, float, tuple, string etc.). But a set cannot have a mutable element, like list, set or dictionary, as its element

```python
# set of integers
my_set = {1, 2, 3}
print(my_set)
Output: {1, 2, 3}

# set of mixed datatypes
my_set = {1.0, "Hello", (1, 2, 3)}
print(my_set)
Output: {1.0, 'Hello', (1, 2, 3)}
```
### How to change a set in Python?
- Sets are mutable. But since they are unordered, indexing have no meaning.

- We cannot access or change an element of set using indexing or slicing. Set does not support it.

- We can add single element using the add() method and multiple elements using the update() method. The update() method can take tuples, lists, strings or other sets as its argument. In all cases, duplicates are avoided.

```python
# initialize my_set
my_set = {1,3}
print(my_set)
my_set.add(2)
print(my_set)
my_set.update([2,3,4])
print(my_set)
my_set.update(5,6,8)
print(my_set)
Output:
{1, 3}
{1, 2, 3}
{1, 2, 3, 4}
{1, 2, 3, 4, 5, 6, 8}
```
### How to remove elements from a set?

- A particular item can be removed from set using methods, discard() and remove().
- The only difference between the two is that, while using discard() if the item does not exist in the set, it remains unchanged. But remove() will raise an error in such condition.

```python
my_set = {1, 3, 4, 5, 6}
print(my_set)
my_set.discard(4)
print(my_set)
my_set.remove(6)
print(my_set)
Output: 
{1, 3, 5, 6}
{1, 3, 5}
```
## Python Set Operations
Sets can be used to carry out mathematical set operations like union, intersection, difference and symmetric difference. We can do this with operators or methods.

[![](http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526998740/15_union_intersection_difference_symmetric.png)](http://http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526998740/15_union_intersection_difference_symmetric.png)

- #### Set Union

------------



Union of A and B is a set of all elements from both sets.
Union is performed using | operator. Same can be accomplished using the method union().

```python
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print(A | B)
Output: 
{1, 2, 3, 4, 5, 6, 7, 8}
```
- #### Set Intersection

------------



Intersection of A and B is a set of elements that are common in both sets.
Intersection is performed using & operator. Same can be accomplished using the method intersection().

```python
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print(A & B)
Output:
{4, 5}
```
- #### Set Difference

------------



Difference of A and B (A - B) is a set of elements that are only in A but not in B. Similarly, B - A is a set of element in B but not in A.
Difference is performed using - operator. Same can be accomplished using the method difference().

```python
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print(A - B)
Output:
{1, 2, 3}
```
- #### Set Symmetric Difference

------------



Symmetric Difference of A and B is a set of elements in both A and B except those that are common in both.
Symmetric difference is performed using ^ operator. Same can be accomplished using the method symmetric_difference().

```python
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print(A ^ B)
Output: 
{1, 2, 3, 6, 7, 8}
```
#####  Set Methods
- add() - Adds an element to the set
- clear() - Removes all elements from the set
- copy() - Returns a copy of the set
 -difference() - Returns the difference of two or more sets as a new set
- difference_update() - Removes all elements of another set from this set
- discard() - Removes an element from the set if it is a member. (Do nothing if the element is not in set)
- intersection() - Returns the intersection of two sets as a new set
- intersection_update() - Updates the set with the intersection of itself and another
- isdisjoint() - Returns True if two sets have a null intersection
- issubset() - Returns True if another set contains this set
- issuperset() - Returns True if this set contains another set
- pop() - Removes and returns an arbitary set element. Raise KeyError if the set is empty
- remove() - Removes an element from the set. If the element is not a member, raise a KeyError
- symmetric_difference() - Returns the symmetric difference of two sets as a new set
- symmetric_difference_update() - Updates a set with the symmetric difference of itself and another
- union() - Returns the union of sets in a new set
- update() - Updates the set with the union of itself and others

# Range In Python

The range() type returns an immutable sequence of numbers between the given start integer to the stop integer.

#### Range Parameters

------------


range() takes mainly three arguments having the same use in both definitions:

- start - integer starting from which the sequence of integers is to be returned
- stop - integer before which the sequence of integers is to be returned. The range of integers end at stop - 1.
- step (Optional) - integer value which determines the increment between each integer in the sequence

#### Return value from range()

------------


range() returns an immutable sequence object of numbers depending upon the definitions used:

** range(stop)**
- Returns a sequence of numbers starting from 0 to stop - 1
- Returns an empty sequence if stop is negative or 0.
range(start, stop[, step])
The return value is calculated by the following formula with the given constraints:

r[n] = start + step*n (for both positive and negative step)
*Where, N >=0 And R[N] < Stop (For Positive Step)
Where, N >= 0 And R[N] > Stop (For Negative Step)
1. (If No Step) Step Defaults To 1. Returns A Sequence Of Numbers Starting From Start And Ending At Stop - 1.
2. (If Step Is Zero) Raises A Valueerror Exception
3. (If Step Is Non-Zero) Checks If The Value Constraint Is Met And Returns A Sequence According To The Formula.

If It Doesn not Meet The Value Constraint, Empty Sequence Is Returned.*

Example 1:
```python
# using range(stop)
print(list(range(10)))
# using range(start, stop)
print(list(range(1, 10)))
Output:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Example 2: 
Create a list of even number between the given numbers using range():
```python
start = 2
stop = 14
step = 2
print(list(range(start, stop, step)))
Output:
[2, 4, 6, 8, 10, 12]
```
Example 3:
Example 3: How range() works with negative step:
```python
start = 2
stop = -14
step = -2
print(list(range(start, stop, step)))
# value constraint not met
print(list(range(start, 14, step)))
Output:
[2, 0, -2, -4, -6, -8, -10, -12]
[]
```

# String in Python

Python has a built-in string class named "str" with many handy features (there is an older module named "string" which you should not use). String literals can be enclosed by either double or single quotes, although single quotes are more commonly used. Backslash escapes work the usual way within both single and double quoted literals -- e.g. \n \' \". A double quoted string literal can contain single quotes without any fuss (e.g. "I didn't do it") and likewise single quoted string can contain double quotes. A string literal can span multiple lines, but there must be a backslash \ at the end of each line to escape the newline. String literals inside triple quotes, """ or ''', can span multiple lines of text.

Python strings are "immutable" which means they cannot be changed after they are created (Java strings also use this immutable style). Since strings can't be changed, we construct *new* strings as we go to represent computed values. So for example the expression ('hello' + 'there') takes in the 2 strings 'hello' and 'there' and builds a new string 'hellothere'.
For example −

var1 = 'Hello World!'
var2 = "Python Programming"

- Accessing Values in Strings
Python does not support a character type; these are treated as strings of length one, thus also considered a substring.

To access substrings, use the square brackets for slicing along with the index or indices to obtain your substring. 
For example −

```python
var1 = 'Hello World!'
var2 = "Python Programming"
print "var1[0]: ", var1[0]
print "var2[1:5]: ", var2[1:5]
Output:
var1[0]:  H
var2[1:5]:  ytho
```
- Updating Strings
You can "update" an existing string by (re)assigning a variable to another string. The new value can be related to its previous value or to a completely different string altogether. 
For example: 

```python
var1 = 'Hello World!'
print "Updated String :- ", var1[:6] + 'Python'
Output:
Updated String :-  Hello Python
```
** String Special Operators**
Assume string variable a holds 'Hello' and variable b holds 'Python', then −

Operator	Description	Example
- (+) Concatenation - Adds values on either side of the operator	a + b will give HelloPython
- (*)	 Repetition - Creates new strings, concatenating multiple copies of the same string	a*2 will give -HelloHello
- []	Slice - Gives the character from the given index	a[1] will give e
- [ : ]	Range Slice - Gives the characters from the given range	a[1:4] will give ell
- in	Membership - Returns true if a character exists in the given string	H in a will give 1
- not in	Membership - Returns true if a character does not exist in the given string	M not in a will give 1
- %	Format - Performs String formatting	See at next section

### Built-in String Methods
Python includes the following built-in methods to manipulate strings −


**1	capitalize()**
Capitalizes first letter of string

**2	center(width, fillchar)**
Returns a space-padded string with the original string centered to a total of width columns.

**3	count(str, beg= 0,end=len(string))**
Counts how many times str occurs in string or in a substring of string if starting index beg and ending index end are given.

**4	decode(encoding='UTF-8',errors='strict')**
Decodes the string using the codec registered for encoding. encoding defaults to the default string encoding.

**5	encode(encoding='UTF-8',errors='strict')**
Returns encoded string version of string; on error, default is to raise a ValueError unless errors is given with 'ignore' or 'replace'.

**6	endswith(suffix, beg=0, end=len(string))**
Determines if string or a substring of string (if starting index beg and ending index end are given) ends with suffix; returns true if so and false otherwise.

**7	expandtabs(tabsize=8)**
Expands tabs in string to multiple spaces; defaults to 8 spaces per tab if tabsize not provided.

**8	find(str, beg=0 end=len(string))**
Determine if str occurs in string or in a substring of string if starting index beg and ending index end are given returns index if found and -1 otherwise.

**9	index(str, beg=0, end=len(string))**
Same as find(), but raises an exception if str not found.

**10	isalnum()**
Returns true if string has at least 1 character and all characters are alphanumeric and false otherwise.

**11	isalpha()**
Returns true if string has at least 1 character and all characters are alphabetic and false otherwise.

**12	isdigit()**
Returns true if string contains only digits and false otherwise.

**13	islower()**
Returns true if string has at least 1 cased character and all cased characters are in lowercase and false otherwise.

**14	isnumeric()**
Returns true if a unicode string contains only numeric characters and false otherwise.

**15	isspace()**
Returns true if string contains only whitespace characters and false otherwise.

**16	istitle()**
Returns true if string is properly "titlecased" and false otherwise.

**17	isupper()**
Returns true if string has at least one cased character and all cased characters are in uppercase and false otherwise.

**18	join(seq)**
Merges (concatenates) the string representations of elements in sequence seq into a string, with separator string.

**19	len(string)**
Returns the length of the string

**20	ljust(width[, fillchar])**
Returns a space-padded string with the original string left-justified to a total of width columns.

**21	lower()**
Converts all uppercase letters in string to lowercase.

**22	lstrip()**
Removes all leading whitespace in string.

**23	maketrans()**
Returns a translation table to be used in translate function.

**24	max(str)**
Returns the max alphabetical character from the string str.

**25	min(str)**
Returns the min alphabetical character from the string str.

**26	replace(old, new [, max])**
Replaces all occurrences of old in string with new or at most max occurrences if max given.

**27	rfind(str, beg=0,end=len(string))**
Same as find(), but search backwards in string.

**28	rindex( str, beg=0, end=len(string))**
Same as index(), but search backwards in string.

**29	rjust(width,[, fillchar])**
Returns a space-padded string with the original string right-justified to a total of width columns.

**30	rstrip()**
Removes all trailing whitespace of string.

**31	split(str="", num=string.count(str))**
Splits string according to delimiter str (space if not provided) and returns list of substrings; split into at most num substrings if given.

**32	splitlines( num=string.count('\n'))**
Splits string at all (or num) NEWLINEs and returns a list of each line with NEWLINEs removed.

**33	startswith(str, beg=0,end=len(string))**
Determines if string or a substring of string (if starting index beg and ending index end are given) starts with substring str; returns true if so and false otherwise.

**34	strip([chars])**
Performs both lstrip() and rstrip() on string.

**35	swapcase()**
Inverts case for all letters in string.

**36	title()**
Returns "titlecased" version of string, that is, all words begin with uppercase and the rest are lowercase.

**37	translate(table, deletechars="")**
Translates string according to translation table str(256 chars), removing those in the del string.

**38	upper()**
Converts lowercase letters in string to uppercase.

**39	zfill (width)**
Returns original string leftpadded with zeros to a total of width characters; intended for numbers, zfill() retains any sign given (less one zero).

**40	isdecimal()**
Returns true if a unicode string contains only decimal characters and false otherwise.

# Dictionary in python
- Dictionary is one of the data type in python.
- It is mapping between key and values. The
  association of a key and a value is called a keyvalue pair or sometimes an item.
- Lists are ordered set of objects, whereas dictionaries
  are unordered sets.
- Items in dictionaries are accessed via keys and not
  via their position.
- Syntax of dictionary:
**{key1:value1, key2:value2,...}**
 Example:
```python
{1:‟abc‟,2:‟xyz‟}
```
- Empty dictionary is denoted by { }.
- Keys are unique within a dictionary while values
  may not be. The values of a dictionary can be of
  any type, but the keys must be immutable.
  
- The function dict creates a new dictionary with no items.
- Because dict is the name of a built-in function, you
should avoid using it as a variable name.

Example:
```python
ex1:
a = dict()
print a
Output:
{}

ex2:
a = dict()
print dict
Output:
<type 'dict'>
```
#### Adding & Accessing items
- To add items to the dictionary, you can use
square brackets:
Example:
```python
a=dict()
a[1] = „abc„
print a
Output:
{1: 'abc'}
```
#### Accessing with key 
An element in the dictionary can also be accessed using the keys

Example:
```python
dict={1:'Name',2:'xyz',2:'abc'}
print dict
print dict[1]
print dict[2]
Output:
{1: 'Name', 2: 'abc'}
Name
abc
```
#### Updating dictionary
- By adding new items/modifying existing entry:
Example:
```python
a = {'a': 'abc', 'b': 'pqr'}
a[„a‟]=„zxc‟
a['c']=8
print a
Output:
{'a': 'zxc', 'b': 'pqr', 'c': 8}
```
- Removing dictionary:
Example:
```python
a={1:'abc', 2:'pqr'}
del a[1]
print(a)
del a[2]
print(a)
a[1]='abc'
print(a)
a.clear()
print(a)
del a
print(a)
Output:
{2: 'pqr'}
{}
{1: 'abc'}
{}
NameError: name 'a' is not defined
```

###Built-in dictionary functions
** cmp(dict1, dict2)**
- cmp() compares two dictionaries based
on key and values.
- Syntax:
> *cmp(dict1, dict2)*

- This method returns 0 if both dictionaries
are equal, -1 if dict1 < dict2 and 1 if dict1> dic2.

** len(dict)**
- Gives the total length of the dictionary. This would
be equal to the number of items in the dictionary.
- Syntax:
> len(dict)len(dict)

Example:
```python
dict = {'Name': 'Zara', 'Age': 7}
print "Length : %d" % len (dict)
dict1 = {}
print "Length : %d" % len (dict1)
Output:
Length : 2
Length : 0
```
### Built-in dictionary methods
**1. dict.clear()**
- Removes all elements of dictionary dict.
- Syntax:
> dict.clear()dict.clear()

- Mutable method
Example:
```python
dict = {'Name': 'Zara', 'Age': 7}
print "Start Len : %d" % len(dict)
dict.clear()
print "End Len : %d" % len(dict)
Output:
Start Len : 2
End Len : 0
```
**2. dict.copy()**
- Returns a copy of dictionary dict
- Syntax:
> dict.copy()dict.copy()

- Non-mutable method
Example:
```python
dict1 = {'Name': 'Zara', 'Age': 7};
dict2 = dict1.copy()
print "New Dictionary : %s" % str(dict2)
Output:
New Dictionary : {'Age': 7, 'Name': 'Zara'}
```
**3. dict.fromkeys()**
- Create a new dictionary with keys from seq and
values set to value.
- Syntax:
> dict.fromkeys(seq[, value])dict.fromkeys(seq[, value])

- seq -- This is the list of values which would be used for
dictionary keys preparation.
- value -- This is optional, if provided then value would be
set to this value.
- Non-mutable method
Ex:
```python
seq = ('name', 'age')
dict = dict.fromkeys(seq)
print "New Dictionary : %s" % str(dict)
dict = dict.fromkeys(seq, 10)
print "New Dictionary : %s" % str(dict)
Output:
New Dictionary : {'name': None, 'age': None}
 New Dictionary : {'name': 10, 'age': 10}
```

**4. dict.has_key(key)**
- Returns true if key is in dictionary dict, false
otherwise
- Syntax:
> dict.has_key(key)

- Non-mutable method 
Ex:
```python
dict = {'Name': 'Zara', 'Age': 7}
print "Value : %s" % dict.has_key('Age')
print "Value : %s" % dict.has_key('Education')
Output:
Value : True
 Value : False
```
**5. dict.items()**
- Returns a list of dict's (key, value) tuple pairs
- Syntax:
> dict.items()dict.items()

- Non-mutable method
Ex:
```python
dict = {'Name': 'Zara', 'Age': 7}
print "Value : %s" % dict.items()
Output:
Value : dict_items([('Name', 'Zara'), ('Age', 7)])
```
**6. dict.keys()**
- Returns list of dictionary dict's keys
- Syntax:
> dict.keys()dict.keys()

- Non-mutable method
Ex:
```python
dict = {'Name': 'Zara', 'Age': 7}
dict1 = {}
print "Value : %s" % dict.keys()
print "Value : %s" % dict1.keys()
Output:
Value : ['Age', 'Name']
 Value : []
```

**7. dict.values()**
- Returns list of dictionary dict's values
- Syntax:
> dict.values()dict.values()

- Non-mutable method
Ex:
```python
dict = {'Name': 'Zara', 'Age': 7}
dict2 = {}
print "Value : %s" % dict.values()
print "Value : %s" % dict2.values()
Output:
Value : [7, 'Zara']
 Value : []
```
**9. pop(), popitem()**
```python
dict = {'Name': 'Zara', 'Age': 7}
print(min(dict))
print(max(dict))
print(dict.pop('Name'))
print(dict)
print(dict.pop('Age'))
print(dict)
dict['N']='Zara'
dict['A']=7
print(dict)
print(dict.popitem())
print(dict)
 Output:
Age
Name
Zara
{'Age': 7}
7
{}
{'N': 'Zara', 'A': 7}
('A', 7)
{'N': 'Zara'}
```

# Python Array : Types and Manipulation
Array is a container which can hold a fix number of items and these items should be of the same type. Most of the data structures make use of arrays to implement their algorithms. Following are the important terms to understand the concept of Array.

**Element**− Each item stored in an array is called an element.
**Index** − Each location of an element in an array has a numerical index, which is used to identify the element.

### Array Declaration and Array Representation
[![Array representation](https://www.tutorialspoint.com/data_structures_algorithms/images/array_declaration.jpg "Array representation")](http://https://www.tutorialspoint.com/data_structures_algorithms/images/array_declaration.jpg "Array representation")

[![Array representation](https://www.tutorialspoint.com/data_structures_algorithms/images/array_representation.jpg "Array representation")](http://https://www.tutorialspoint.com/data_structures_algorithms/images/array_representation.jpg "Array representation")

- Index starts with 0.
- Array length is 10 which means it can store 10 elements.
- Each element can be accessed via its index. For example, we can fetch an element at index 6 as 9.

### Basic Operations
Following are the basic operations supported by an array.

1. Traverse − print all the array elements one by one.

2. Insertion − Adds an element at the given index.

3. Deletion − Deletes an element at the given index.

4. Search − Searches an element using the given index or by the value.

5. Update − Updates an element at the given index.

Array is created in Python by importing** array module** to the python program. Then the array is declared as shown eblow.

> from array import *
arrayName = array(typecode, [Initializers])

Typecode are the codes that are used to define the type of value the array will hold. Some common typecodes used are:

|Typecode| Value|
|-----|-----|
|b|Represents signed integer of size 1 byte/td>|
|B|Represents unsigned integer of size 1 byte|
|c|Represents character of size 1 byte|
|i|Represents signed integer of size 2 bytes|
|I|Represents unsigned integer of size 2 bytes|
|f|Represents floating point of size 4 bytes|
|d|Represents floating point of size 8 bytes|


- The below code creates an array named array1.

```python
from array import *

array1 = array('i', [10,20,30,40,50])
for x in array1:
	print(x)
Output
10
20
30
40
50

```
### Accessing Array Element
We can access each element of an array using the index of the element. The below code shows how


from array import *

```python
array1 = array('i', [10,20,30,40,50])
print (array1[0])
print (array1[2])

Output:
10
30
```

### Insertion Operation
Insert operation is to insert one or more data elements into an array. Based on the requirement, a new element can be added at the beginning, end, or any given index of array.

Here, we add a data element at the middle of the array using the python in-built insert() method.


```python
from array import *

array1 = array('i', [10,20,30,40,50])
array1.insert(1,60)
for x in array1:
	print(x)

Output
10
60
20
30
40
50
```

### Deletion Operation
Deletion refers to removing an existing element from the array and re-organizing all elements of an array.

Here, we remove a data element at the middle of the array using the python in-built remove() method.


```python
from array import *

array1 = array('i', [10,20,30,40,50])
array1.remove(40)
for x in array1:
	print(x)

Output
10
20
30
50
```
### Search Operation
You can perform a search for an array element based on its value or its index.

Here, we search a data element using the python in-built index() method.


```python
from array import *

array1 = array('i', [10,20,30,40,50])
print (array1.index(40))
Output
3
```
### Update Operation
Update operation refers to updating an existing element from the array at a given index.

Here, we simply reassign a new value to the desired index we want to update.


```python
from array import *

array1 = array('i', [10,20,30,40,50])
array1[2] = 80
for x in array1:
	print(x)

Output
10
20
80
40
50
```
# Multidimensional Array in Python

#### What is a 2-d array and how to create it using a list object ?
The 2-d array:
From machine learning data frames to matrices, the most widely used array is 2-d array.
Basically a 2-d array is defined as an array of arrays. 

As of now we have seen an array holding data like [ 1, 2, 3, 4, 5] which can be interpreted as line in coordinate geometry if these points are to be plotted. What if I say I have a data of 5 students for 5 subjects:

Student 1 = [98, 95, 92, 99, 78]
Student 2 = [95, 85, 68, 48, 45]
Student 3 = [98, 95, 92, 99, 25]
Student 4 = [98, 72, 58, 99, 75]
Student 5 = [98, 95, 92, 99, 48]

Now you can have five different lists to store this data but this will be inefficient and frankly speaking not a good construct for using list. Moreover, it is even possible for small data but in the case of 100000 students what will we do? Clearly this construct is not acceptable as a good programmer.


Here comes 2-d arrays to the rescue. What if we can store these five arrays of student in an array? Well, we can! This is what array of arrays means. We will store these arrays inside an array itself. Since if you plot these elements considering them geometric points then you will require two planes for it(namely x and y), thus called 2-d array or two dimensional array.

The 2-d array for the same will be:

> student_data = [ [98, 95, 92, 99, 78], [95, 85, 68, 48, 45], [98, 95, 92, 99, 25], [98, 72, 58, 99, 75], [98, 95, 92, 99, 48] ]

To access the elements we will use two indexes, first index to define the location of list where our element is stored and second index to define the location of element in that list.

For example we want to access the mark of student 3 of subject 4, then we can access it using

> student_data[2][3]

> [![](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)](http://https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)

**Note:We have used index no 2 for location 3 because indexing starts at 0**


#### How to insert elements in 2-d array?

Consider if we want to store results of student 6 in these 2-d array then we can use in-built function append().

[![](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/2Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)](http://https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/2Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)

Example

1. student6 = [ 56, 89, 48, 96, 45]
And we want to store it in student_data then,

2. student_data.append(student6)
These will add the elements in last position of the 2-d array. So basically the general syntax is:

3. array_name.append(list_name_to_add)

#### How to update elements of 2-d array?


To understand this let us continue taking the example of student_data.
Now lets say student3 gives reexamination of subject5 and got 98 marks, now this increased marks has to be updated. So how can we achieve this? We can simply achieve this using assignment operator.

> student_data[ 2 ][ 4 ] = 98
[![](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/4Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)](http://https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/4Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)


So generalised syntax to update any element of the 2-d array:
> Array_name[index_of_sub_array][ index_of_element_to_update ] = new_value

#### How to remove elements of 2-d array?
Now lets see how we can remove any elements of 2-d array. Suppose student4 left the school and his record has to be removed then we will have to remove his entire entry or we can say array. So to remove elements of list object we use pop function.

So to remove the data of student4 we can do as follows:

> student_data.pop( 3 )
[![](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/6Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)](http://https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/6Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)


The generalised syntax being:
> array_name.pop(index_of_sub_array_to_remove)


However in certain scenarios we have to delete a specific element instead of complete array. We can achieve the same using pop function.
Consider student1 unenrolled from subject2 then his entry for subject2 has to be deleted. So to delete subject2 entry of student1,

> student_data[ 0 ].pop(1)
[![](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/7Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)](http://https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/08/7Image-An-intuitive-approach-to-2-D-arrays-in-Python-Edureka.jpg)

So the generalized syntax for deleting an element of 2-d array will be:

> Array_name[index_of_sub_array].pop(index_of_element_to_remove)


# any() in Python:

The any() method takes an iterable (list, string, dictionary etc.) in Python.

any() returns:

- True if at least one element of an iterable is true
- False if all elements are false or if an iterable is empty

|When|	Return Value|
|-----|-----|
|All values are true|	True|
|All values are false|	False|
|One value is true (others are false)|	True|
|One value is false (others are true)|	True|
|Empty Iterable|	False|

Example:
```python
l = [1, 3, 4, 0]
print(any(l))

l = [0, False]
print(any(l))

l = [0, False, 5]
print(any(l))

l = []
print(any(l))

Output:
True
False
True
False

```

# Python all():

The all() method takes a single parameter:

iterable - any iterable (list, tuple, dictionary, etc.) which contains the elements
Return Value from all()

The all() method returns:

- True - If all elements in an iterable are true
- False - If any element in an iterable is false

Truth table for all():

|When|	Return Value|
|-----|-----|
|All values are true|	True|
|All values are false|	False|
|One value is true (others are false)|	False|
|One value is false (others are true)|	False|
|Empty Iterable|	True|

Example:

```python
# all values true
l = [1, 3, 4, 5]
print(all(l))

# all values false
l = [0, False]
print(all(l))

# one false value
l = [1, 3, 4, 0]
print(all(l))

# one true value
l = [0, False, 5]
print(all(l))

# empty iterable
l = []
print(all(l))

Output:
True
False
False
False
True
```

# Accumulate():

### The Itertools Module
This module is a collection of functions. We are going to explore each one of these function. If you have any questions, suggestion, or correction, please put them in the comments below. I address them as soon as possible.

- accumulate()

> itertools.accumulate(iterable[, func])itertools.accumulate(iterable[, func])

This function makes an iterator that returns the results of a function. Functions can be passed around very much like variables. The accumulate() function takes a function as an argument. It also takes an iterable. It returns the accumulated results. The results are themselves contained in an iterable.
Code
```python
data = [1, 2, 3, 4, 5]
result = itertools.accumulate(data, operator.mul)
for each in result:
    print(each)
Output
1
2
6
24
120
```
The operator.mul takes two numbers and multiplies them.
operator.mul(1, 2)
2
operator.mul(2, 3)
6
operator.mul(6, 4)
24
operator.mul(24, 5)
120


In this next example will will use the max function.
Code
```python
data = [5, 2, 6, 4, 5, 9, 1]
result = itertools.accumulate(data, max)
for each in result:
    print(each)
Output
5
5
6
6
6
9
9
```
The max function returns the largest item.
5
max(5, 2)
5
max(5, 6)
6
max(6, 4)
6
max(6, 5)
6
max(6, 9)
9
max(9, 1)
9


Passing a function is optional.
Code
```python
data = [5, 2, 6, 4, 5, 9, 1]
result = itertools.accumulate(data)
for each in result:
    print(each)
Output
5
7
13
17
22
31
32
```
**If no function is designated the items will be summed.**
5
5 + 2 = 7
7 + 6 = 13
13 + 4 = 17
17 + 5 = 22
22 + 9 = 31
31 + 1 = 32

# Subset in Python:
Set A is said to be the subset of set B if all elements of A are in B .

The syntax of issubset() is:
> A.issubset(B)

The issubset() returns

- True if A is a subset of B
- False if A is not a subset of B


[![](https://cdn.programiz.com/sites/tutorial2program/files/python-subset.jpg)](http://https://cdn.programiz.com/sites/tutorial2program/files/python-subset.jpg)


```python
# initializing list 
test_list = [9, 4, 5, 8, 10] 
sub_list = [10, 5] 

# printing original lists 
print ("Original list : " + str(test_list)) 
print ("Original sub list : " + str(sub_list)) 

# using issubset() to 
# check subset of list 
flag = 0
if(set(sub_list).issubset(set(test_list))): 
	flag = 1
# printing result 
if (flag) : 
	print ("Yes, list is subset of other.") 
else : 
	print ("No, list is not subset of other.") 

Output:

Original list : [9, 4, 5, 8, 10]
Original sub list : [10, 5]
Yes, list is subset of other.
```
# Superset in Python:
[![](https://cdn.programiz.com/sites/tutorial2program/files/python-superset.jpg)](http://https://cdn.programiz.com/sites/tutorial2program/files/python-superset.jpg)

Set A is said to be the superset of set B if all elements of B are in A.

Here, set A is a superset of set B and B is a subset of set A.

The syntax of issuperset() is:

> A.issuperset(B)

Return Value from issuperset()
The issuperset() returns

- True if A is a superset of B
- False if A is not a superset of B

```python
A = {1, 2, 3, 4, 5}
B = {1, 2, 3}
C = {1, 2, 3}

# Returns True
print(A.issuperset(B))

# Returns False
print(B.issuperset(A))

# Returns True
print(C.issuperset(B))

Output:
True
False
True
```

# Frozenset in Python:

Frozen set is just an immutable version of a Python set object. While elements of a set can be modified at any time, elements of frozen set remains the same after creation.

Due to this, frozen sets can be used as key in Dictionary or as element of another set. But like sets, it is not ordered (the elements can be set at any index).

The syntax of frozenset() method is:

> frozenset([iterable])

frozenset() Parameters
The frozenset() method optionally takes a single parameter:

- iterable (Optional) - the iterable which contains elements to initialize the frozenset with. Iterable can be set, dictionary, tuple, etc.

- Return value from frozenset()

The frozenset() method returns an immutable frozenset initialized with elements from the given iterable.

```python
# tuple of vowels
vowels = ('a', 'e', 'i', 'o', 'u')

fSet = frozenset(vowels)
print('The frozen set is:', fSet)
print('The empty frozen set is:', frozenset())

Output:
The frozen set is: frozenset({'i', 'a', 'u', 'e', 'o'})
The empty frozen set is: frozenset()
```

# pop() and popitem()
### pop()
Lists can be used as stacks and the operator pop() is used to take an element from the stack. So far, so good, for lists, but does it make sense to have a pop() method for dictionaries. After all a dict is not a sequence data type, i.e. there is no ordering and no indexing. Therefore, pop() is defined differently with dictionaries. Keys and values are implemented in an arbitrary order, which is not random, but depends on the implementation.
If D is a dictionary, then D.pop(k) removes the key k with its value from the dictionary D and returns the corresponding value as the return value, i.e. D[k].
If the key is not found a KeyError is raised:
```python
en_de = {"Austria":"Vienna", "Switzerland":"Bern", "Germany":"Berlin", "Netherlands":"Amsterdam"}
capitals = {"Austria":"Vienna", "Germany":"Berlin", "Netherlands":"Amsterdam"}
capital = capitals.pop("Austria")
print(capital)
Vienna

print(capitals)
{'Netherlands': 'Amsterdam', 'Germany': 'Berlin'}
capital = capitals.pop("Switzerland")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'Switzerland'
```

If we try to find out the capital of Switzerland in the previous example, we raise a KeyError. To prevent these errors, there is an elegant way. The method pop() has an optional second parameter, which can be used as a default value:
```python
capital = capitals.pop("Switzerland", "Bern")
print(capital)
Bern

capital = capitals.pop("France", "Paris")
print(capital)
Paris

capital = capitals.pop("Germany", "München")
print(capital)
Berlin

```
 
### popitem()
popitem() is a method of dict, which doesn't take any parameter and removes and returns an arbitrary (key,value) pair as a 2-tuple. If popitem() is applied on an empty dictionary, a KeyError will be raised.
```python
capitals = {"Springfield":"Illinois", "Augusta":"Maine", "Boston": "Massachusetts", "Lansing":"Michigan", "Albany":"New York", "Olympia":"Washington", "Toronto":"Ontario"}
(city, state) = capitals.popitem()
(city, state)
('Olympia', 'Washington')
print(capitals.popitem())
('Albany', 'New York')
print(capitals.popitem())
('Boston', 'Massachusetts')
print(capitals.popitem())
('Lansing', 'Michigan')
print(capitals.popitem())
('Toronto', 'Ontario')

```
































